# goit-algo-hw-09

У цьому завданні я реалізував два підходи до знаходження мінімальної кількості монет для видачі заданої суми: 

1. **Жадібний алгоритм** (`find_coins_greedy`)
2. **Алгоритм динамічного програмування** (`find_min_coins`)

Мета — порівняти їх ефективність за часом виконання та продуктивністю.

---

## Оцінка часової складності

### Жадібний алгоритм
- Складність: **O(n)**, де `n` — кількість номіналів монет.
- Працює швидко, оскільки просто перебирає номінали та віднімає їх від суми.

### Динамічне програмування
- Складність: **O(n * S)**, де `S` — сума, для якої шукається розподіл монет.
- Будує таблицю мінімальних кількостей монет для кожної можливої суми.

---

## Аналіз продуктивності

| Amount | Greedy Time (s) | DP Time (s) |
|--------|----------------|-------------|
| 113    | 0.00000610     | 0.00025530  |
| 26     | 0.00000360     | 0.00004310  |
| 60     | 0.00000270     | 0.00008530  |
| 73     | 0.00000300     | 0.00010080  |
| 999    | 0.00000200     | 0.00113440  |
| 1234   | 0.00000250     | 0.00135210  |

### Висновки

- Жадібний алгоритм працює **значно швидше**, особливо на великих сумах.
- Алгоритм динамічного програмування вимагає більше обчислень і повільніший.
- У цьому випадку **жадібний алгоритм дає оптимальний результат**, оскільки номінали монет підібрані так, що він завжди знаходить мінімальну кількість монет.
- Якщо б набір монет був іншим (наприклад, [9, 6, 1]), жадібний алгоритм міг би дати неоптимальне рішення, а динамічне програмування — правильне.

### Висновок для реальних застосувань
- Якщо набір номіналів добре підібраний (як у нашому випадку), **жадібний алгоритм є оптимальним** через швидкість виконання.
- Якщо набір номіналів нестандартний, варто застосовувати **динамічне програмування**, хоч воно і працює повільніше.
